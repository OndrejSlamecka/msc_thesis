\chapter{Evaluation}
\label{ch_evaluation}

This chapter explains the basics of working with PRISM model checker,
then describes how are the algorithms implemented as a part of PRISM,
how they behave on small models, and how do they compare to other
methods on standard models.

\section{PRISM, Probabilistic Model Checker}

PRISM \parencite{prism}
({\em probabilistic model checker}) is a program/framework
for formal modelling and analysis of probabilistic systems.
We show how to use PRISM to describe MDPs, their properties,
and how to check them.

\subsection*{Describing MDPs with the PRISM language}
PRISM has a language for description of Markov decision processes
based on the formalism of Alur and Henzinger \parencite{ReactiveModules}.
A brief example is given below for the readers who wish to try our
algorithms on small models which they can describe and solve by hand.
The the definitive guide to the language is available online on the
PRISM homepage \parencite{prism_lang}.

The PRISM language describes {\em modules} (interacting actors),
their states (using variables) and transitions between the states.
An example single PRISM language line is below. The line translates as:
if condition \verb|guard| is satisfied the actor can choose action \verb|act|
and
with probability \verb|prob_1| update \verb|update_1| will happen,
with probability \verb|prob_2| update \verb|update_2| will happen,
and so on.

\begin{verbatim}
[act] guard -> prob_1 : update_1 + prob_2 : update_2 + ...
\end{verbatim}

An example module is described below and is equivalent to the MDP
depicted in \autoref{moduleM}.

\smallskip
\begin{verbatim}
mdp // Tell PRISM this file describes an MDP
module M
    s : [0 .. 3] init 0;
    [a] s=0 -> (s'=0);
    [b] s=0 -> 0.9:(s'=1) + 0.1:(s'=0);
    [c] s=1 -> 0.9:(s'=2) + 0.1:(s'=1);
    [d] s=2 -> (s'=2);
endmodule
\end{verbatim}
\smallskip

\begin{figure}
\begin{tikzpicture}
    \tikzstyle{state}=[thick,draw=black,circle]
    \tikzstyle{transition}=[draw,shape=circle,fill=black]
    \tikzstyle{loop}=[looseness=5, in=120, out=60]

    \node[state] at (0,0) (s0) {$s = 0$};
    \node[transition] at (2,0) (s0b) {};
    \node[state] at (4,0) (s1) {$s = 1$};
    \node[transition] at (6,0) (s1b) {};
    \node[state] at (8,0) (s2) {$s = 2$};

    \draw (s0) edge [loop,->] node [above] {$a$} (s0);

    \draw (s0) edge [bend left, ->] node [midway, above] {$b$} (s0b);
    \draw[->] (s0b) -- (s1) node [midway, above] {0.9};
    \draw (s0b) edge [bend left, ->] node [midway, below] {0.1} (s0);

    \draw (s1) edge [bend left, ->] node [midway, above] {$c$} (s1b);
    \draw[->] (s1b) -- (s2) node [midway, above] {0.9};
    \draw (s1b) edge [bend left, ->] node [midway, below] {0.1} (s1);

    \draw (s2) edge [loop,->] node [above] {$d$} (s2);
\end{tikzpicture}
\caption{Module M}
\label{moduleM}
\end{figure}

A property we might be interested in is the maximum probability of
eventually reaching state \verb|s=2|, this could be described to PRISM
with the string \verb|Pmax=? [F s=2]|. A user can use standard logical
connectives for describing the target states. At the moment our
implementation does not support timed properties (e.g. $F <= x$ is not
supported), however, it is not hard to implement such functionality.

\subsection*{Running PRISM}

We have a model description and a property but before we analyze it
PRISM has to be installed.
There is a modified version of PRISM distributed with this thesis. It
can be built by issuing the \verb|make| command inside the
\verb|prism| directory. Java is a required prerequisite.
Once built the PRISM binary is available at \verb|prism/bin/prism|.

Now use PRISM to analyze the model -- its name is passed as the first
argument and \verb|-pf| specifies the property we want to check.
The \verb|-ex| flag will be described later.
Running the command below
confirms our expectations: the maximum probability of eventually
reaching state \verb|s=2| is 1.

\medskip
\begin{verbatim}
./prism modelM.nm -pf 'Pmax=? [F s=2]' -ex
\end{verbatim}
\medskip

The following tells PRISM to use MCTS-BRTDP where the next state in
BRTDP is chosen to be the one with highest upper bound.

\medskip
\begin{verbatim}
./prism modelM.nm -pf 'Pmax=? [F s=2]' -heuristic_verbose \
 -heuristic MCTS_BRTDP -next_state HIGH_PROB
\end{verbatim}
\medskip

The UCB constant can be chosen with
\verb|-ucb1constant|. If not provided the value is set to
$1/\sqrt{2}$.

The method can be chosen out of the following: \verb|MCTS_BRTDP|,
\verb|MCTS| (TODO: Rename to BMCTS), \verb|BRTDP|, \verb|BRTDP_UCB|,
or empty for value  iteration.
The next state heuristics are
\verb|HIGH_PROB|, \verb|MAX_DIFF|.
The variation of BRTDP using UCB to select the next action is chosen by
adding switch \verb|-next_action 2|.

\subsection*{Data structures}
The \verb|-ex| switch used in the value iteration example above tells
PRISM to use the explicit computation engine.
The explicit computation engine explores the MDP and stores it in
a sparse matrix before the value iteration algorithm is run.

PRISM offers three symbolic computation engines based on binary decision
diagrams, namely MTBDD (multi-terminal BDD, \verb|-mtbdd| switch),
sparse TODO.

All the heuristic methods use a data structure implemented in
\verb|prism/src/heuristic/CachedModelGenerator.java|.
With this {\em model generator} data structure PRISM will not build the
whole MDP from its description unless asked to.
Asking the model generator to reveal parts of the model results in the
construction of an {\em explicit model} which is cached in the memory.
Such construction is computationally expensive and often unnecessary
which is when the heuristic methods perform so well.

\section{Implementation}

We describe how the pseudocode described in \autoref{ch_mcts} maps to
the implementation in PRISM. The implementation can be found in
\verb|prism/src/heuristics|.

To represent the MCTS tree we use classes \verb|MCTree.java| and
\linebreak
\verb|MCNode.java|. The tree class has an important method \verb|unfold|
which asks the model generator to add the next states of a given state
to the explicit model and adds them to the tree.

The next state heuristics are implemented in a straightforward way
inside directory \verb|nextstate|. The UCB heuristic is implemented in
directory \verb|treeheuristic|.

MCTS-BRTDP is implemented in \verb|search/MctsBrtdp.java|. The entry
point is \verb|computeProb|, subsequently
\verb|monteCarloTreeSearch| is invoked until the stopping condition
is reached (see method \verb|isDone|). Method
\verb|monteCarloTreeSearch| first selects and expands a tree state
(using \verb|treeSelectAndExpand|),
then uses \verb|exploreAndUpdate| implemented in BRTDP
(\verb|search/HeuristicBrtdp.java|) as the rollout and propagates
the values using updates to the root.

As we have observed problems only once during thousands of runs on our
models, we have not implemented the removal of subtrees induced by nodes
corresponding to a state which is contained in a collapsed MEC.

BMCTS is implemented by modifying MCTS-BRTDP. The modification is turned
on when the flag \verb|next_action 5| is added to a command using
MCTS-BRTDP. This change makes the BRTDP implementation chose next action
uniformly at random instead of the BRTDP-way by upper bound.

\section{Behaviour on Small Models}

For small models we use visualization to observe how MCTS-BRTDP solves
them. To render the progress of MCTS-BRTDP into a series of pictures,
the last lines of \verb|MctsBrtdp.monteCarloTreeSearch| has to be uncommented.
Due to the randomized nature of the algortihms a researcher should
observe more runs before making conclusions.

We present three simple models and example runs of MCTS-BRTDP in the
attached files. The first is a model resembling a binary tree, second is
the BRTDP adversary (TODO: Third)
* On the thing below, might be good to compare with BRTDP.
\begin{verbatim}
  init -> cloud of tens of states -> target
       \> easy path               -> target
\end{verbatim}

\subsection*{Binary Tree Model}

The ``binary tree'' model features two decisions ({\em left} and {\em
right}) in each state and each decision has two successors,
the {\em left} one occurs with probability 0.2,
the {\em right} one with 0.8. A path through the model goes through 4 states
before it reaches a ``leaf'' state. Every leaf state of the subtree
induced by the left decision in root leads to state 85, every leaf state
of the other subtree leads to state 86. We ask what is the maximum
probability of reaching state 85.

By running the program repeatedly it can be observed that MCTS-BRTDP
almost evenly explores the branches in a balanced way while utilizing
BRTDP rollouts to search for promising paths. BRTDP on its own
selects a branch it knows the least about until it learns the upper bound
for the right part of the tree is 0 and therefore it has to focus on the
left part. The VCB for MCTS-BRTDP focuses on the left part quickly due
to successful results, however it still explores the right part to look
for possible improvements overlooked earlier.

TODO: draw start.

\subsection*{BRTDP adversary}

In \autoref{brtdp_adversary} MCTS-BRTDP has a clear advantage as it
traverses to a leaf of the tree and then adds a node to it with each iteration.
Soon the tree reaches the target state and it remains to perform updates
equivalent to value iteration.


\section{PRISM Benchmark Suite and Other Models}

Experimental evaluation was done mainly on standard models
distributed with PRISM. Most of the MDPs described by these models are
concerned with network configuration where randomness plays important
role in achieving a common goal. We provide a brief description of the
{\em zeroconf} model to offer basic familiarity and refer the reader to
thorough descriptions of all the models on PRISM's website
\href{http://www.prismmodelchecker.org/casestudies/}{www.prismmodelchecker.org/casestudies/}.

We also created new MDPs by combining the PRISM models with the MDP
which is hard for BRTDP (\autoref{brtdp_adversary}). We describe them in
the last subsection.

The description of all the models in the PRISM language can be found inside
\verb|tests/reachability/models| in the source codes attached to this
thesis.

\subsection*{Zero-configuration networking}

{\em
Zeroconf}\footnote{\href{http://www.prismmodelchecker.org/casestudies/zeroconf.php}{http://www.prismmodelchecker.org/casestudies/zeroconf.php}} model corresponds to a set of computers establishing a
network without a given leader. Such leader could be a human setting
static IP addresses or a DHCP server which would need to be configured
up front -- in both cases there is extra work required.

The zero-configuration networking protocol describes how should the
computers proceed. Upon connecting to the network a computer picks an IP
address at random and broadcasts its choice via an ARP packet called
{\em probe} repeated $K$ times ($K=4$ by the standard) with two second
delay. If another computer responds to one these
ARP packets the original sender will then pick another IP address and
repeat the process. If it does not receive a response it then broadcasts
twice an ARP packet asserting this computer's use of the chosen IP
address.

TODO

%\subsection*{IEEE 1394 FireWire}

%FireWire is an interface standard for serial bus

%\subsection*{Wireless LAN}

%\subsection*{Randomised Consensus Shared Coin Protocol}

%\subsection*{mer}

\subsection*{Combining PRISM models with BRTDP adversary}

We combined the MDPs in two ways. The first is by {\em branching} and the
resulting shape is shown in \autoref{fig:branching}.

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
    \tikzstyle{state}=[thick,draw=black,circle]
    \tikzstyle{transition}=[draw,shape=circle,fill=black]
    \tikzstyle{loop}=[looseness=5, in=120, out=60]

    \node[state] at (0,0) (s0) {0};
    \node[transition] at (1.6,0) (s0b) {};
    \node[state] at (3.2,0) (s1) {1};
    \node[transition] at (4.8,0) (s1b) {};
    \node[state] at (6.4,0) (s2) {2};
    \node[transition] at (8,0) (s2b) {};
    \node[state] at (9.6,0) (s3) {3};

    \node [cloud, draw,cloud puffs=10,cloud puff arc=120, aspect=2,
        inner ysep=1em] at (2,-3) (zconf) {zeroconf};

    \draw (s0) edge [bend right, ->] node [midway, right] {$b$} (zconf);

    \draw (s0) edge [bend left, ->] node [midway, above] {$a$} (s0b);
    \draw[->] (s0b) -- (s1) node [midway, above] {0.01};
    \draw (s0b) edge [bend left, ->] node [midway, above] {0.99} (s0);

    \draw (s1) edge [bend left, ->] node [midway, above] {} (s1b);
    \draw[->] (s1b) -- (s2) node [midway, above] {0.01};
    \draw (s1b) edge [bend left, ->] node [midway, above] {0.99} (s0);

    \draw (s2) edge [bend left, ->] node [midway, above] {} (s2b);
    \draw[->] (s2b) -- (s3) node [midway, above] {0.01};
    \draw (s2b) edge [bend left, ->] node [midway, above] {0.99} (s0);

    \draw (s3) edge [loop,->] node [above] {} (s3);

\end{tikzpicture}
\end{center}
    \caption{Combining zeroconf model with the BRTDP adversary in a
    branching manner.}
    \label{fig:branching}
\end{figure}

The second way to combine MDPs is parallel composition, which is done by
using modules in the PRISM language. Each state of the composed MDP is a member
of the product set of the sets of states of each of the modules. The
choice of the next transition is non-deterministic, i.e. a strategy does
not decide only which transition in a module to use but also which
module to use (the strategy for the MDP can be viewed as a member of the
product set of the set of strategies for each of the modules).

\section{Experimental Comparison}

On the following pages we present the results of our measurements.
In the presented tables rows correspond to models and their
configuration, columns to methods and chosen exploration constant.  Each
table cell contains comma separated running time in seconds and number of visited
states of the MDP\footnote{The number of states is, unlike running time,
agnostic to implementation details.}\textsuperscript{,}\footnote{Value iteration has to construct the
whole model in memory so the number of states it visits is the total
number of states.}. Each experiment was repeated
ten times and the results were averaged\footnote{There was no
significant variance in the measured times so averaging provides
representative results.}.

TODO: describe the machine and JVM configuration.

TODO: set up an example
runbenchmarks script so that anyone can verify our results right away.
TODO: Our full results are stored in measurements attached with the thesis

In \autoref{table:general_comparison} we can see
TODO: Table 1, comparison of VI, BRTDP, BRTDP-UCB, MCTS-BRTDP on the
PRISM suite (zeroconf, firewire-impl, wlan, coin, leader, mer).
Note that MCTS-BRTDP is almost as fast as BRTDP.

TODO: Somewhere where BMCTS is good?

TODO: Table 2, comparison of VI, BRTDP, MCTS-BRTDP on branch-zeroconf,
about 6 lines, 3 where BRTDP < MCTS-BRTDP < VI, and 3 where it is the
other way.
Note that overall MCTS-BRTDP does
not do the worst or the best anywhere, making it a universal choice.

Measurements show that the only method which works on at least some of the
composition-zeroconf models is value iteration (specifically with $K = 40$ the
model has 141 thousand states and VI solves it, regardless of choice of $N$).
Other methods always run out of time.
But on composition-wlan6 we observed that MCTS-BRTDP is the only method which
can actually solve the problem. Moreover it takes only few thousands of states
to be explored and a few seconds of running time.

TODO: Impact of UCB constant.

\begin{landscape}

\begin{table}
\begin{tabularx}{\textwidth}{ l  | c | c | c | c | c }
     & VI          &  BRTDP, MAX-DIFF   & BRTDP-UCB & MCTS-BRTDP \\
zeroconf $N=1, K=10$ &        204, &   \\
zeroconf $N=x, K=z$ &        204, &   \\
zeroconf $N=y, K=zz$ &        204, &   \\
wlan6 &        204, &   \\
coin... &        204, &   \\
leader &        204, &   \\
mer &        204, &   \\
\end{tabularx}
\caption{Comparison on standard PRISM models}
\label{table:general_comparison}
\end{table}

\begin{table}
\begin{tabularx}{\textwidth}{ l  | c | c  }
branch\_zeroconf &  BRTDP, MAX-DIFF   &   VI      \\
$N=1, K=10$      &               46,  &       204, \\
\end{tabularx}
\caption{caption}
\label{table:branch_zconf}
\end{table}

%\begin{table}
%\begin{tabularx}{\textwidth}{ l  | c | c
       %&  BRTDP, MAX-DIFF   &       VI     &  MCTS-BRTDP   & BRTDP-UCB \\
%wlan6  &             46,  &       204, &               & \\
%\end{tabularx}
%\caption{Composition models}
%\label{tab:composition}
%\end{table}
\end{landscape}

%\section{Model Structure and MCTS Performance}

%TODO: Explain why MCTS-BRTDP performs almost as well as BRTDP on some
%models

%We discuss what are the possible reasons MCTS performs well on some
%models and worse on others. (See e.g. On Adversarial Search Spaces and
%Sampling-Based Planning for a similar comparison between MCTS on Chess
%and Go).

%From the Chess and Go comparison it would seem that MCTS based methods would
%not perform well in verification as there are usually many dead ends.
%However by tuning the parameters and trying variants of the algorithms
%we have achieved better results on several models than other known methods.

%TODO :-/

%can we extrapolate where will each method do well from small instances of the models?
